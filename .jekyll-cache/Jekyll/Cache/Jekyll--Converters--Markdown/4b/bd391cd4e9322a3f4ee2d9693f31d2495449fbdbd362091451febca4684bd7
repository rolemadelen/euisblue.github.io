I"1<h2 id="dcp란"><strong>DCP란?</strong></h2>
<p><a href="https://www.dailycodingproblem.com">Daily Coding Problem</a>을 구독하면 매일 한 개의 코딩 문제를 이메일로 받을 수 있습니다.</p>

<p>실제 회사에서 개발자들이 받았던 면접 문제들을 기반으로 만든 문제라고 하는데 단순히 면접을 떠나서 
이런 문제들은 사고력과 논리력에 도움이 될거라고 생각해서 필자도 풀어보려고 한다.</p>

<p>문제들은 C/C++와 현재 공부중인 Ruby로 작성할 예정이다.</p>

<p>다만 같은 코드를 다른 언어로 글에 올리는 것은 의미가 없다 생각해서 Ruby 코드만 올리려고 한다.</p>

<p>C 또는 C++로 작성한 코드를 보고싶다면 필자의 <a href="https://github.com/muicode/DCP">GitHub</a>를 확인해주길 바란다.</p>

<p>참고로 DCP에서 프리미엄 멤버의 경우 정답 코드를 다음 날 보내주는데 필자는 그렇지 않은 관계로 정답 코드를 확인 할 수가 없다.</p>

<p>그러니 오류가 있다면 피드백을, 더 좋은 방법이 있다면 코드의 공유를 해주면 감사할 따름이다.</p>

<p>그럼 첫 번째 문제를 풀어보자.</p>

<p><br /></p>

<h2 id="dcp-1"><strong>DCP #1</strong></h2>
<p>이 문제는 실제 구글 면접에서 나온 질문입니다.</p>

<p>정수 배열과 정수 k가 주어졌을 때, 배열 속 두 정수의 합이 k가 되는지 확인하는 프로그램을 작성하세요.</p>

<p>예를들어, 배열의 값으로 <code class="highlighter-rouge">[10, 15, 3, 7]</code> 그리고 <code class="highlighter-rouge">k</code>로 <code class="highlighter-rouge">17</code>이 주어질 경우, <code class="highlighter-rouge">10 + 7</code>은 <code class="highlighter-rouge">k</code> 이므로 참을 반환합니다.</p>

<p>보너스: 원 패스(one pass)로 문제를 풀어보세요.</p>

<p><a href="en-dcp-1.html#dcp1">원문 읽기</a></p>

<p><br /></p>

<h2 id="코드--설명"><strong>코드 &amp; 설명</strong></h2>
<p><a href="https://github.com/muicode/DCP/blob/master/problem1/dcp1.cpp">C++ 코드 보기</a></p>

<h3 id="bruteforce"><strong>Bruteforce</strong></h3>
<p>일차원적으로 접근한다면 배열의 모든 원소를 하나하나 확인하는 브루트포스 방법이 있다.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bruteforce</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="nf">size</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="p">(</span><span class="mi">0</span> <span class="o">...</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">...</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">k</span>
                <span class="nb">puts</span> <span class="s2">"found: </span><span class="si">#{</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2"> + </span><span class="si">#{</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="si">}</span><span class="s2"> = </span><span class="si">#{</span><span class="n">k</span><span class="si">}</span><span class="s2">"</span>
                <span class="k">return</span>
            <span class="k">end</span>
        <span class="k">end</span>
    <span class="k">end</span>
    <span class="nb">puts</span> <span class="s2">"none exists"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>배열의 첫 번째 원소부터 시작해 나머지 원소들과 하나 씩 더해가면서 <code class="highlighter-rouge">k</code>와 일치하는지 확인한다.
여기서는 <code class="highlighter-rouge">puts</code>를 사용했지만 일치하면 참을 아니면 거짓을 반환한다.</p>

<p>시간복잡도는 <strong>O(n^2)</strong></p>

<p>연산 하면서 사용되는 추가적인 메모리는 없기 때문에 공간 복잡도는 <strong>O(1)</strong>이다.</p>

<p><br /></p>

<h3 id="one-pass"><strong>One-Pass</strong></h3>

<p>브루트포스는 아무래도 데이터의 크기가 커지면 커질수록 느려질 수 밖에 없다.</p>

<p>이 문제를 one-pass로 다시 한 번 구현해보자. 해시맵를 사용한다.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">one_pass</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">arr</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">n</span><span class="o">|</span>
        <span class="k">if</span> <span class="n">m</span><span class="p">.</span><span class="nf">has_key?</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span>
            <span class="nb">puts</span> <span class="s2">"found: </span><span class="si">#{</span><span class="n">k</span> <span class="o">-</span> <span class="n">n</span><span class="si">}</span><span class="s2"> + </span><span class="si">#{</span><span class="n">n</span><span class="si">}</span><span class="s2"> = </span><span class="si">#{</span><span class="n">k</span><span class="si">}</span><span class="s2">"</span>
            <span class="k">return</span>
        <span class="k">else</span>
            <span class="n">m</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">end</span>
    <span class="k">end</span>
    <span class="nb">puts</span> <span class="s2">"none exists"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>새로운 원소(<code class="highlighter-rouge">n</code>)에 접근하는 순간순간 <code class="highlighter-rouge">n</code>의  key가<code class="highlighter-rouge">k - n</code>인지 확인하고 맞으면 참을, <br />
그렇지 않으면 <code class="highlighter-rouge">n</code>과 <code class="highlighter-rouge">k - n</code>를 각각 key, value로 해시에 추가한다.</p>

<p><br /></p>

<h3 id="시간과-공간복잡도"><strong>시간과 공간복잡도</strong></h3>

<p><code class="highlighter-rouge">Hash</code>의 <code class="highlighter-rouge">[]</code> 메소드는 아래와 같이 구현되어 있다.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 출처: https://apidock.com/ruby/v2_5_5/Hash/%5B%5D</span>

<span class="no">VALUE</span>
<span class="n">rb_hash_aref</span><span class="p">(</span><span class="no">VALUE</span> <span class="nb">hash</span><span class="p">,</span> <span class="no">VALUE</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">st_data_t</span> <span class="n">val</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="no">RHASH</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ntbl</span> <span class="o">||</span> <span class="o">!</span><span class="n">st_lookup</span><span class="p">(</span><span class="no">RHASH</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ntbl</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">rb_hash_default_value</span><span class="p">(</span><span class="nb">hash</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="no">VALUE</span><span class="p">)</span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>정확히 st_lookup이 어떻게 구현되어 있는지 모르겠지만 lookup table하면 보통 O(1)인걸로 알고있으니 O(1)으로 봐도 무방하지 않을까 싶다.</p>

<p><code class="highlighter-rouge">has_key</code>의 구현은 아래와 같다.</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 출처: https://apidock.com/ruby/v2_5_5/Hash/has_key%3F</span>

<span class="no">VALUE</span>
<span class="n">rb_hash_has_key</span><span class="p">(</span><span class="no">VALUE</span> <span class="nb">hash</span><span class="p">,</span> <span class="no">VALUE</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="no">RHASH</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ntbl</span><span class="p">)</span>
        <span class="k">return</span> <span class="no">Qfalse</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">st_lookup</span><span class="p">(</span><span class="no">RHASH</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ntbl</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">Qtrue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="no">Qfalse</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>여기도 마찬가지로 O(1)이다.</p>

<p>고로 one-pass로 작성한 위 코드의 시간복잡도는 <strong>O(n)</strong>이고 공간복잡도는 최소 <strong>O(1)</strong>, 최대 <strong>O(n)</strong>이다.</p>

<p><br /></p>

<h2 id="관련-글-"><strong>관련 글</strong> <a id="related"></a></h2>

<div class="relatedPosts">





  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    
      <div>
      ┈ <a href="/dcp/2019/10/27/ko-dcp-7.html">DCP 7: 메세지 해독하기</a>
      </div>
      
      
    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    
      <div>
      ┈ <a href="/dcp/2019/10/25/ko-dcp-6.html">DCP 6: XOR 연결 리스트</a>
      </div>
      
      
    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    
      <div>
      ┈ <a href="/dcp/2019/10/20/ko-dcp-5.html">DCP 5: CAR과 CDR</a>
      </div>
      
      
    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    
      <div>
      ┈ <a href="/dcp/2019/09/21/ko-dcp-4.html">DCP 4: 가장 낮은 양수</a>
      </div>
      
      
    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    
      <div>
      ┈ <a href="/dcp/2019/09/20/ko-dcp-3.html">DCP 3: 직렬화 &amp; 역직렬화</a>
      </div>
      
      
        

</div>

:ET