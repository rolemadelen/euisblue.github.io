I"3)<h2 id="목차">목차</h2>
<ul>
  <li><a href="#problem">문제</a></li>
  <li><a href="#solution">코드 (Ruby)</a></li>
  <li><a href="#explain">설명</a></li>
  <li><a href="#related">관련 글</a></li>
</ul>

<hr />

<p><br /></p>

<h2 id="문제-">문제 <a id="problem"></a></h2>

<p><a href="https://leetcode.com/problems/serialize-and-deserialize-bst/">449. Serialize and Deserialize BST</a></p>

<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, 
or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>

<p>Design an algorithm to serialize and deserialize a <strong>binary search tree</strong>. 
There is no restriction on how your serialization/deserialization algorithm should work. 
You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>

<p><strong>The encoded string should be as compact as possible.</strong></p>

<p><strong>Note:</strong> Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>

<p><br /></p>

<h2 id="코드-ruby-">코드 (Ruby) <a id="solution"></a></h2>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="kp">nil</span>
        <span class="k">return</span> <span class="s1">'X'</span>
    <span class="k">end</span>
    
    <span class="n">left</span> <span class="o">=</span> <span class="n">serialize</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="nf">left</span><span class="p">)</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">serialize</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="nf">right</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="s2">"</span><span class="si">#{</span><span class="n">root</span><span class="p">.</span><span class="nf">val</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">left</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">right</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">' '</span><span class="p">)</span>
    <span class="n">deserialize_helper</span> <span class="n">tokens</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">deserialize_helper</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">curr</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">shift</span>
    
    <span class="k">if</span> <span class="n">curr</span> <span class="o">==</span> <span class="s1">'X'</span>
        <span class="k">return</span> <span class="kp">nil</span>
    <span class="k">end</span>
    
    <span class="n">root</span> <span class="o">=</span> <span class="no">TreeNode</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
    <span class="n">root</span><span class="p">.</span><span class="nf">left</span> <span class="o">=</span> <span class="n">deserialize_helper</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">root</span><span class="p">.</span><span class="nf">right</span> <span class="o">=</span> <span class="n">deserialize_helper</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">root</span>
<span class="k">end</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="설명-">설명 <a id="explain"></a></h2>

<h3 id="serialize">Serialize</h3>

<p><code class="highlighter-rouge">preorder</code> 순회 방법을 사용한다.</p>

<p><code class="highlighter-rouge">#6-7</code>에서 <code class="highlighter-rouge">root</code>의 왼쪽과 오른쪽 자식의 노드를 찾기 위해 함수를 재귀적으로 호출하고 있다.  <br />
<code class="highlighter-rouge">nil</code>에 도달할 경우 필자가 임의로 정한 <code class="highlighter-rouge">X</code>라는 문자열을 <code class="highlighter-rouge">nil</code>대신 반환한다(<code class="highlighter-rouge">#2-4</code>; 추후에 디코딩 과정에서 사용).
마지막으로 문자화한 BST를 반환한다(<code class="highlighter-rouge">#9</code>).</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="kp">nil</span>
        <span class="k">return</span> <span class="s1">'X'</span>
    <span class="k">end</span>
    
    <span class="n">left</span> <span class="o">=</span> <span class="n">serialize</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="nf">left</span><span class="p">)</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">serialize</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="nf">right</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="s2">"</span><span class="si">#{</span><span class="n">root</span><span class="p">.</span><span class="nf">val</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">left</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">right</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="deserialize">Deserialize</h3>

<p><code class="highlighter-rouge">data</code>는 문자열 포맷이다. <br />
문자열에서 각 노드들을 분리하고(<code class="highlighter-rouge">#2</code>) 이를 helper 함수를 사용해 트리를 재구성한다(<code class="highlighter-rouge">#3</code>).</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">' '</span><span class="p">)</span>
    <span class="n">deserialize_helper</span> <span class="n">tokens</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><br /></p>

<p><code class="highlighter-rouge">data.shift</code>를 이용해 배열의 첫 번째 값을 가져온 다음 배열에서 지운다(<code class="highlighter-rouge">#2</code>).</p>

<p>가져온 값이 <code class="highlighter-rouge">X</code>일 경우, 현 노드는 아무 값이 없는 <code class="highlighter-rouge">nil</code> 노드라는 의미가 되기 때문에 <code class="highlighter-rouge">nil</code>을 리턴한다(<code class="highlighter-rouge">#4-6</code>).
<code class="highlighter-rouge">X</code>가 아닐 경우, 새로운 노드를 만들고 다시 왼쪽과 오른쪽 자식의 값을 재귀적으로 찾는다(<code class="highlighter-rouge">#8-10</code>).</p>

<p>연산이 끝났으면 <code class="highlighter-rouge">root</code>노드를 반환한다.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">deserialize_helper</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">curr</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">shift</span>
    
    <span class="k">if</span> <span class="n">curr</span> <span class="o">==</span> <span class="s1">'X'</span>
        <span class="k">return</span> <span class="kp">nil</span>
    <span class="k">end</span>
    
    <span class="n">root</span> <span class="o">=</span> <span class="no">TreeNode</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
    <span class="n">root</span><span class="p">.</span><span class="nf">left</span> <span class="o">=</span> <span class="n">deserialize_helper</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">root</span><span class="p">.</span><span class="nf">right</span> <span class="o">=</span> <span class="n">deserialize_helper</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">root</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>시간복잡도는 모든 인코딩 과정에서 모든 노드를 한 번씩 방문하기 때문에 <strong>O(n)</strong>이 된다. <br />
공간복잡도는 재귀함수가 돌때마다 스택 프레임의 크기를 증가시키기 때문에 이 역시 <strong>O(n)</strong>이 된다.</p>

<p><br /></p>

<h2 id="관련-글-">관련 글 <a id="related"></a></h2>
<ul>
  <li><a href="/dcp/2019/09/20/ko-dcp-3.html">Daily Coding Problem #3</a></li>
</ul>
:ET