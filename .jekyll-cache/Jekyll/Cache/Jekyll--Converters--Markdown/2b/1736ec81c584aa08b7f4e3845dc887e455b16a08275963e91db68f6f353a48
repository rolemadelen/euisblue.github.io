I"X1<h2 id="dcpとは"><strong>DCPとは?</strong></h2>
<p><a href="https://www.dailycodingproblem.com">Daily Coding Problem</a>ブログ購読をすると、毎日一つのプログラミング問題をメールにて送信します。</p>

<p>実際会社の面接問題だったらしいなので、思考力と論理力に役立つから筆者もやってみようと思う。
問題たちはC/C++言語と今勉強中のRubyで作成する予定だ。
他の言語でも同じコードを記事に書くのは意味がないと思うからRubyのコードだけ書くつもりだ。
C言語とかC++のコードは<a href="https://github.com/muicode/DCP">GitHub</a>から確認できる。</p>

<p>ちなみにDCPのプレミアム・メンバーの場合問題の答えを次の日送れあげるけど、筆者はそうじゃないからコタへがはもらえない。なので、もしエラーとかもっといい方法があるとき教えてくれたら感謝する。</p>

<p>では、第一の問題を解いてみよう。</p>

<p><br /></p>

<h2 id="dcp-1"><strong>DCP #1</strong></h2>
<p>この問題は実際Googleの面接からの質問です。</p>

<p>整数配列と整数<code class="highlighter-rouge">k</code>が与えられたとき、配列中の２つの数字の和が<code class="highlighter-rouge">k</code>になるかならないか確認するプログラムを作成してください。</p>

<p>例えば、配列<code class="highlighter-rouge">[10, 15, 3, 7]</code>と<code class="highlighter-rouge">17</code>が<code class="highlighter-rouge">k</code>に与えられたとき、<code class="highlighter-rouge">10 + 7</code>は<code class="highlighter-rouge">k</code>なのでTrueを返します。</p>

<p><br />
<strong>ボーナス：</strong> One Passで解けますか。</p>

<p><a href="en-dcp-1.html#dcp1">原文を読む</a></p>

<p><br /></p>

<h2 id="コード--説明"><strong>コード ＆ 説明</strong></h2>
<p><a href="https://github.com/muicode/DCP/blob/master/problem1/dcp1.cpp">C++コード</a></p>

<h3 id="bruteftrue"><strong>Bruteftrue</strong></h3>
<p>一次元的に見たら配列のすべての要素を確認する、ブルートフォースアルゴリズムがある。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bruteforce</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="nf">size</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="p">(</span><span class="mi">0</span> <span class="o">...</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">...</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">k</span>
                <span class="nb">puts</span> <span class="s2">"found: </span><span class="si">#{</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2"> + </span><span class="si">#{</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="si">}</span><span class="s2"> = </span><span class="si">#{</span><span class="n">k</span><span class="si">}</span><span class="s2">"</span>
                <span class="k">return</span>
            <span class="k">end</span>
        <span class="k">end</span>
    <span class="k">end</span>
    <span class="nb">puts</span> <span class="s2">"none exists"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>配列の一番目の要素から初めて、その以外の要素たちを一つずつ足しながら<code class="highlighter-rouge">k</code>と一致するか確認する。
一致するとtrueを、じゃないとfalseを返す。</p>

<p>時間複雑度は <strong>O(n^2)</strong>。 <br />
演算しながら使用される追加のメモリはないので空間複雑度は <strong>O(1)</strong>になる。</p>

<p><br /></p>

<h3 id="one-pass"><strong>One-Pass</strong></h3>

<p>ブルートフォースアルゴリズムはデータが大きければ大きほど遅くなるので良くない。</p>

<p>この問題をone-passで実装してみよう。HashMapを使用する。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">one_pass</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">arr</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">n</span><span class="o">|</span>
        <span class="k">if</span> <span class="n">m</span><span class="p">.</span><span class="nf">has_key?</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span>
            <span class="nb">puts</span> <span class="s2">"found: </span><span class="si">#{</span><span class="n">k</span> <span class="o">-</span> <span class="n">n</span><span class="si">}</span><span class="s2"> + </span><span class="si">#{</span><span class="n">n</span><span class="si">}</span><span class="s2"> = </span><span class="si">#{</span><span class="n">k</span><span class="si">}</span><span class="s2">"</span>
            <span class="k">return</span>
        <span class="k">else</span>
            <span class="n">m</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">end</span>
    <span class="k">end</span>
    <span class="nb">puts</span> <span class="s2">"none exists"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>新しい要素（<code class="highlighter-rouge">n</code>）に接近する瞬間<code class="highlighter-rouge">n</code>のkeyが<code class="highlighter-rouge">k - n</code>と同じか確認して当たるとtrueを返す。 <br />
違うと<code class="highlighter-rouge">n</code>と <code class="highlighter-rouge">k - n</code>を（key、value）ペアでhashに追加する。</p>

<p><br /></p>

<h3 id="時間空間複雑度"><strong>時間・空間複雑度</strong></h3>

<p><code class="highlighter-rouge">Hash</code>の<code class="highlighter-rouge">[]</code>メソードは下記なように実装されてある。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 출처: https://apidock.com/ruby/v2_5_5/Hash/%5B%5D</span>

<span class="no">VALUE</span>
<span class="n">rb_hash_aref</span><span class="p">(</span><span class="no">VALUE</span> <span class="nb">hash</span><span class="p">,</span> <span class="no">VALUE</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">st_data_t</span> <span class="n">val</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="no">RHASH</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ntbl</span> <span class="o">||</span> <span class="o">!</span><span class="n">st_lookup</span><span class="p">(</span><span class="no">RHASH</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ntbl</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">rb_hash_default_value</span><span class="p">(</span><span class="nb">hash</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="no">VALUE</span><span class="p">)</span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>正確に<code class="highlighter-rouge">st_lookup</code>がどうやって実装されてあるかはわからないけど、lookupテーブルだからO(1)だと思ってもいいだろ。</p>

<p><code class="highlighter-rouge">has_key</code>の実装は下記のようだ。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 출처: https://apidock.com/ruby/v2_5_5/Hash/has_key%3F</span>

<span class="no">VALUE</span>
<span class="n">rb_hash_has_key</span><span class="p">(</span><span class="no">VALUE</span> <span class="nb">hash</span><span class="p">,</span> <span class="no">VALUE</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="no">RHASH</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ntbl</span><span class="p">)</span>
        <span class="k">return</span> <span class="no">Qfalse</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">st_lookup</span><span class="p">(</span><span class="no">RHASH</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ntbl</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">Qtrue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="no">Qfalse</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>この関数の時間複雑度もO(1)だ。</p>

<p>で、one-passで解いたコードの時間複雑度は<strong>O(n)</strong>。空間複雑度は最小<strong>O(1)</strong>, 最大<strong>O(n)</strong>になる。</p>

<p><br /></p>

<h2 id="関連記事-"><strong>関連記事</strong> <a id="related"></a></h2>

<div class="relatedPosts">





  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    
      <div>
      ┈ <a href="/dcp/2019/10/27/ja-dcp-7.html">DCP 7・メッセージ解読</a>
      </div>
      
      
    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    
      <div>
      ┈ <a href="/dcp/2019/10/25/ja-dcp-6.html">DCP 6・XOR連結リスト</a>
      </div>
      
      
    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    
      <div>
      ┈ <a href="/dcp/2019/10/20/ja-dcp-5.html">DCP 5・CARとCDR</a>
      </div>
      
      
    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    
      <div>
      ┈ <a href="/dcp/2019/09/21/ja-dcp-4.html">DCP 4・一番低い正数</a>
      </div>
      
      
    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    
      <div>
      ┈ <a href="/dcp/2019/09/20/ja-dcp-3.html">DCP 3・直列化 ＆ 逆直列化</a>
      </div>
      
      
        

</div>

:ET