I" !<p><a href="https://www.dailycodingproblem.com">Daily Coding Problem</a>을 구독하면 매일 한 개의 코딩 문제를 이메일로 받을 수 있습니다.</p>

<h2 id="dcp-2"><strong>DCP #2</strong></h2>
<p>이 문제는 실제 우버(Uber) 면접에서 나온 질문입니다.</p>

<p>주어진 정수의 배열로 새로운 배열을 만들려고 합니다.</p>

<p>새로운 배열 <code class="highlighter-rouge">i</code>번째 원소에는, 기존 배열 <code class="highlighter-rouge">i</code>번째 원소를 제외한 모든 값들의 곱이 저장되어 있습니다.</p>

<p>예를들어 <code class="highlighter-rouge">[1, 2, 3, 4, 5]</code> 배열이 주어졌을 때, 새로운 배열의 <code class="highlighter-rouge">[0]</code>번째 원소에는 기존 배열의 <code class="highlighter-rouge">1</code>을 제외한 모든 값들의 곱(<code class="highlighter-rouge">2 * 3 * 4 * 5</code>)인 <code class="highlighter-rouge">120</code>이 들어가게 됩니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>입력: [1, 2, 3, 4, 5]
출력: [120, 60, 40, 30, 24]
</code></pre></div></div>

<p>보너스: 나누기 연산자를 사용할 수 없다면?</p>

<p><a href="en-dcp-2.html#dcp2">원문 읽기</a></p>

<p><br /></p>

<h2 id="코드--설명"><strong>코드 &amp; 설명</strong></h2>
<p><a href="https://github.com/muicode/DCP/blob/master/problem2/dcp2.c">C 코드 보기</a></p>

<h3 id="나누기-사용-가능"><strong>나누기 사용 가능</strong></h3>
<p>모든 원소들의 곱을 구하고 배열을 돌면서 해당 원소의 값으로 나눠주면 된다. 새로운 배열을 만들지 않아도 되기때문에 추가적인 메모리 사용이 없다.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">with_div</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">product</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="nf">inject</span><span class="p">(:</span><span class="o">*</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="nf">length</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="p">(</span><span class="mi">0</span> <span class="o">...</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">product</span><span class="o">/</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">end</span>
    <span class="n">arr</span>
<span class="k">end</span>
</code></pre></div></div>

<p>시간복잡도: <strong>O(n)</strong> <br />
공간복잡도: <strong>O(1)</strong></p>

<p><br /></p>

<h3 id="나누기-사용-불가능"><strong>나누기 사용 불가능</strong></h3>
<p>나누기를 사용 할 수 없다?</p>

<p>첫 번째(이자 마지막) 방법은 이중 반복문을 사용 하는 것 이다. 배열을 돌면서 해당 원소와 다른 원소들의 값을 곱한 후 미자막에 새로운 배열에 저장한다.</p>

<p>계속해서 기존 배열의 값들을 사용해야 되기 때문에 새로운 배열을 만들어야 한다.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">without_div</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="nf">length</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="p">(</span><span class="mi">0</span> <span class="o">...</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">prod</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="p">(</span><span class="mi">0</span> <span class="o">...</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">i</span>
                <span class="n">prod</span> <span class="o">*=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">end</span>
        <span class="k">end</span>
        <span class="n">ans</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">prod</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">ans</span>
<span class="k">end</span>
</code></pre></div></div>

<p>시간복잡도: <strong>O(n^2)</strong> <br />
공간복잡도: <strong>O(n)</strong></p>

<p>아래는 루비식으로 짠 코드인데 사실 상 위 코드와 별반 다른게 없다.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">wo_division2</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="nf">length</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span> <span class="o">*</span> <span class="n">n</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="p">(</span><span class="mi">0</span> <span class="o">...</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span> <span class="o">-</span> <span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]).</span><span class="nf">inject</span><span class="p">(:</span><span class="o">*</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">ans</span>
<span class="k">end</span>
</code></pre></div></div>

<p>시간복잡도: <strong>O(n^2)</strong> <br />
공간복잡도: <strong>O(n)</strong></p>

<p>나누기 연산이 없을 때 도저히 O(n^2) 이하의 방법으로는 풀 방법을 떠올리지 못해서 찾아봤는데 역시 O(n)에 푸는게 가능하기는 한 것 같다.
이 <a href="https://dev.to/cwetanow/daily-coding-problem-2-21pj">블로그</a>의 코멘트들을 보면 O(n)으로 푼 많은 코드들을 확인 할 수 있다.</p>

<p><br /></p>

<h2 id="관련-글-"><strong>관련 글</strong> <a id="related"></a></h2>

<div class="relatedPosts">





  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    
      <div>
      ┈ <a href="/dcp/2019/10/27/ko-dcp-7.html">DCP 7: 메세지 해독하기</a>
      </div>
      
      
    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    
      <div>
      ┈ <a href="/dcp/2019/10/25/ko-dcp-6.html">DCP 6: XOR 연결 리스트</a>
      </div>
      
      
    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    
      <div>
      ┈ <a href="/dcp/2019/10/20/ko-dcp-5.html">DCP 5: CAR과 CDR</a>
      </div>
      
      
    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    
      <div>
      ┈ <a href="/dcp/2019/09/21/ko-dcp-4.html">DCP 4: 가장 낮은 양수</a>
      </div>
      
      
    

  

    
    

    

    

  

    
    

    

    

  

    
    

    

    
      <div>
      ┈ <a href="/dcp/2019/09/20/ko-dcp-3.html">DCP 3: 직렬화 &amp; 역직렬화</a>
      </div>
      
      
        

</div>
:ET