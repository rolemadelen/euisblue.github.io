I"(<h2 id="contents">Contents</h2>
<ul>
  <li><a href="#problem">Problem</a></li>
  <li><a href="#solution">Solution</a></li>
  <li><a href="#explain">Explanation</a></li>
  <li><a href="#related">Related Posts</a></li>
</ul>

<hr />

<p><br /></p>

<h2 id="problem-">Problem <a id="problem"></a></h2>

<p><a href="https://leetcode.com/problems/serialize-and-deserialize-bst/">449. Serialize and Deserialize BST</a></p>

<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, 
or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>

<p>Design an algorithm to serialize and deserialize a <strong>binary search tree</strong>. 
There is no restriction on how your serialization/deserialization algorithm should work. 
You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>

<p><strong>The encoded string should be as compact as possible.</strong></p>

<p><strong>Note:</strong> Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>

<p><br /></p>

<h2 id="solution-">Solution <a id="solution"></a></h2>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="kp">nil</span>
        <span class="k">return</span> <span class="s1">'X'</span>
    <span class="k">end</span>
    
    <span class="n">left</span> <span class="o">=</span> <span class="n">serialize</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="nf">left</span><span class="p">)</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">serialize</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="nf">right</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="s2">"</span><span class="si">#{</span><span class="n">root</span><span class="p">.</span><span class="nf">val</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">left</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">right</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">' '</span><span class="p">)</span>
    <span class="n">deserialize_helper</span> <span class="n">tokens</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">deserialize_helper</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">curr</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">shift</span>
    
    <span class="k">if</span> <span class="n">curr</span> <span class="o">==</span> <span class="s1">'X'</span>
        <span class="k">return</span> <span class="kp">nil</span>
    <span class="k">end</span>
    
    <span class="n">root</span> <span class="o">=</span> <span class="no">TreeNode</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
    <span class="n">root</span><span class="p">.</span><span class="nf">left</span> <span class="o">=</span> <span class="n">deserialize_helper</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">root</span><span class="p">.</span><span class="nf">right</span> <span class="o">=</span> <span class="n">deserialize_helper</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">root</span>
<span class="k">end</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="explanation-">Explanation <a id="explain"></a></h2>

<h3 id="serialize">Serialize</h3>

<p>I used preorder traversal to serialize and deserialze bst.</p>

<p>Line <code class="highlighter-rouge">#6-7</code> recursively call its function to serialize <code class="highlighter-rouge">root</code>â€™s left and right child.
Once these nodes become <code class="highlighter-rouge">nil</code>, return the encoded string (<code class="highlighter-rouge">'X'</code>) that later you can use to decode (<code class="highlighter-rouge">#2-4</code>).
And finally return the full encoded string (<code class="highlighter-rouge">#9</code>).</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="kp">nil</span>
        <span class="k">return</span> <span class="s1">'X'</span>
    <span class="k">end</span>
    
    <span class="n">left</span> <span class="o">=</span> <span class="n">serialize</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="nf">left</span><span class="p">)</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">serialize</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="nf">right</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="s2">"</span><span class="si">#{</span><span class="n">root</span><span class="p">.</span><span class="nf">val</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">left</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">right</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="deserialize">Deserialize</h3>

<p>My <code class="highlighter-rouge">data</code> is in a string format. We need to separate each encoded nodes (<code class="highlighter-rouge">#2</code>) and pass it on to the helper function I made (<code class="highlighter-rouge">#3</code>).</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">' '</span><span class="p">)</span>
    <span class="n">deserialize_helper</span> <span class="n">tokens</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><br /></p>

<p><code class="highlighter-rouge">data.shift</code> pops the front element and removes it from the array (<code class="highlighter-rouge">#1</code>).</p>

<p>We used the character <code class="highlighter-rouge">X</code> to represent the <code class="highlighter-rouge">nil</code> node. So when the current value is <code class="highlighter-rouge">X</code> we simply return <code class="highlighter-rouge">nil</code> (<code class="highlighter-rouge">#4-6</code>).
Otherwise, we create a new node with the value received from the <code class="highlighter-rouge">data</code> and repeat the process recursively to find its left and right node (<code class="highlighter-rouge">#8-10</code>).</p>

<p>When everything is done, we return the root.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">deserialize_helper</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">curr</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">shift</span>
    
    <span class="k">if</span> <span class="n">curr</span> <span class="o">==</span> <span class="s1">'X'</span>
        <span class="k">return</span> <span class="kp">nil</span>
    <span class="k">end</span>
    
    <span class="n">root</span> <span class="o">=</span> <span class="no">TreeNode</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
    <span class="n">root</span><span class="p">.</span><span class="nf">left</span> <span class="o">=</span> <span class="n">deserialize_helper</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">root</span><span class="p">.</span><span class="nf">right</span> <span class="o">=</span> <span class="n">deserialize_helper</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">root</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Time complexity is <strong>O(n)</strong> because we visit every nodes during the serialization.<br />
Space complexity is also <strong>O(n)</strong> because of the stack frame added during the recursion procedure.</p>

<p><br /></p>

<h2 id="related-posts-">Related Posts <a id="related"></a></h2>
<ul>
  <li><a href="/dcp/2019/09/20/en-dcp-3.html">Daily Coding Problem #3</a></li>
</ul>
:ET