I"Å<h2 id="what-is-binary-search"><strong>What is Binary Search?</strong></h2>

<p>Binary Search is a search algorithm that finds the target element from a <strong>sorted list</strong>.</p>

<p>The algorithm first finds the midpoint of the list, compare its value with the target element and decide 
which half (left or right) to proceed to compare.</p>

<p><img src="/assets/images/algorithm/search/search-binary-search-1.jpg" alt="Binary Search" /></p>

<p>If our target number is greater than <code class="highlighter-rouge">5</code>, we can ignore the left half and vice versa. By  halving the 
size of the list at every iteration, the speed of searching escalates substantially compare to
Linear Search Algorithm.</p>

<p>Hereâ€™s a simple comparison. <br />
When we have 1000 data, linear search requires 1000 operations in worst case scenario to find the element.
But with binary search, it only requires 10 operations at most.</p>

<p><br /></p>

<h2 id="implementation-in-ruby"><strong>Implementation in Ruby</strong></h2>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">binarySearch</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">low</span> <span class="o">&gt;</span> <span class="n">high</span>

    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">mid</span>
    <span class="k">elsif</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">val</span>
        <span class="n">binarySearch</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">low</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
    <span class="k">else</span>
        <span class="n">binarySearch</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><a href="https://github.com/muicode/coding/blob/master/algorithm/search/binsearch.cpp">View C++ implementation</a></p>

<p><br /></p>

<h2 id="explanation"><strong>Explanation</strong></h2>

<p><em>Assume the list is sorted in ascending order. If its in descending order, flip the comparison sign.</em></p>

<p>Find the midpoint: <code class="highlighter-rouge">mid = low + (high - low) / 2;</code></p>

<p>We can use <code class="highlighter-rouge">mid = (low + high) / 2</code> to find the midpoint, however, thereâ€™s a potential risk of having 
overflow-error. If youâ€™re using a language where integer overflow is handled automatically (e.g. Ruby), 
you probably donâ€™t need to worry about it, but its still important to understand why weâ€™re using such formula.</p>

<p>Now we compare the middle element with the target element and there are 4 possible cases.</p>
<ol>
  <li>middle element == <code class="highlighter-rouge">target</code>
    <ul>
      <li>Simple.
 Return the index.
 <img src="/assets/images/algorithm/search/search-binary-search-2.jpg" alt="Binary Search" /></li>
    </ul>
  </li>
  <li>middle element &gt; <code class="highlighter-rouge">target</code>
    <ul>
      <li><code class="highlighter-rouge">target</code> is located on the <strong>left half</strong> of the list so change <code class="highlighter-rouge">high</code> to 
  <code class="highlighter-rouge">middle - 1</code> and repeat the process.
  <img src="/assets/images/algorithm/search/search-binary-search-3.jpg" alt="Binary Search" /></li>
    </ul>
  </li>
  <li>middle element &lt; <code class="highlighter-rouge">target</code>
    <ul>
      <li><code class="highlighter-rouge">target</code> is located on the <strong>right half</strong> of the list so change <code class="highlighter-rouge">low</code> to 
  <code class="highlighter-rouge">middle + 1</code> and repeat the process.
  <img src="/assets/images/algorithm/search/search-binary-search-4.jpg" alt="Binary Search" /></li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">target</code> not in the list
    <ul>
      <li>When we repeatedly halve the list, <code class="highlighter-rouge">low</code> will eventually become greater than <code class="highlighter-rouge">high</code>.
 This means the <code class="highlighter-rouge">target</code> is not in the list. In this case return <code class="highlighter-rouge">-1</code> or whatever value you decided to reperesent DNE.</li>
    </ul>
  </li>
</ol>
:ET