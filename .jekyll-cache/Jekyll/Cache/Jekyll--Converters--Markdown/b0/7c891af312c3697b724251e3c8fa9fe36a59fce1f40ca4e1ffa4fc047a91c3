I"^2<h2 id="목차">목차</h2>
<ul>
  <li><a href="#algo">문자열 뒤집기</a></li>
  <li>풀이
    <ul>
      <li><a href="#pointer">방법 1: 포인터 연산</a></li>
      <li><a href="#array">방법 2: 배열</a></li>
      <li><a href="#stack">방법 3: 스택</a></li>
      <li><a href="#q">방법 4: 큐</a></li>
    </ul>
  </li>
  <li><a href="#app">사용 사례</a></li>
  <li><a href="#try">풀어 볼 문제</a></li>
  <li><a href="#ref">Reference</a></li>
</ul>
<hr />

<p><br /></p>

<h2 id="문자열-뒤집기-">문자열 뒤집기 <a id="algo"></a></h2>
<p>주어진 문자열 맨 끝에서부터 하나하나 저장해나가면 역순이 되는, 이론 뿐만이 아니라 구현도 간단한
알고리즘이다. 이 알고리즘을 구현하는 방법에는 여러 방법이 있는데 여기서는 포인터, 배열, 스택, 그리고 큐를 이용해 문자열을 역순으로 만드는 방법에 대해 알아본다.</p>

<p>설명이 아닌, 단순히 이렇게 저렇게 할 수 있다를 보여주기 위한 것으로, 코드의 설명은 최소화로 한다.</p>

<p><br /></p>
<h2 id="풀이">풀이</h2>
<h3 id="포인터-연산">포인터 연산<a id="pointer"></a></h3>
<p>개인적으로 가장 간단한 방법이면서 코드 자체도 간결하고 직관적이어서 좋은 방법이라고 생각한다.</p>

<p>포인터 연산을 이용한 방법으로 두 개의 포인터를 사용한다.첫 번째 포인터 <code class="highlighter-rouge">p</code>는 문자열의 처음을 
가리키고, 두 번째 포인터 <code class="highlighter-rouge">q</code>는 문자열의 마지막을 가리킨다.
그 다음 <code class="highlighter-rouge">*p</code>와 <code class="highlighter-rouge">*q</code> 서로의 값을 <code class="highlighter-rouge">p &lt; q</code>일 동안 반복하면서 교체하면 역순이 된 문자열의 값을 얻게된다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* String Reverse using two pointers */</span>
<span class="kt">void</span> <span class="nf">strrevptr</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">line</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">line</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">line</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">q</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
		<span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

		<span class="o">++</span><span class="n">p</span><span class="p">;</span>
		<span class="o">--</span><span class="n">q</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="배열-">배열 <a id="array"></a></h3>
<p>배열을 이용한 방법으로 이론은 포인터 연산과 똑같다. 다만 개인적으로 코드가 포인터를 사용했을 때
보다 깔끔해 보이지 않아서 선호하는 편은 아니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* String reverse using array */</span>
<span class="kt">void</span> <span class="nf">strrevindex</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">line</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">bound</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">bound</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="n">size</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)];</span>
		<span class="n">line</span><span class="p">[</span><span class="n">size</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="스택">스택<a id="stack"></a></h3>
<p>스택의 LIFO (Last-In First-Out, 선입후출) 특성을 이용한 방법으로 
문자열의 문자를 전부 스택에 <code class="highlighter-rouge">push</code>한 다음 차례대로 스택에서 <code class="highlighter-rouge">pop</code> 하면 된다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Reverse string using a stack</span>
<span class="kt">void</span> <span class="nf">revstrstk</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">line</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">stack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">stk</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">line</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">stk</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
		<span class="o">++</span><span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">stk</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
		<span class="n">stk</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="큐-">큐 <a id="q"></a></h3>
<p>굳이 큐를 사용해야 하나 싶지만, 큐를 가지고 구현 하려면 두 개의 큐를 사용해야 한다.</p>

<p>첫 번째 큐가 <code class="highlighter-rouge">q1</code>, 두 번째 큐가 <code class="highlighter-rouge">q2</code>라고 가정하고 반복되는 부분을 간단히 설명해보자면,</p>
<ol>
  <li><code class="highlighter-rouge">q1</code>에 문자 추가</li>
  <li><code class="highlighter-rouge">q2</code>에 <code class="highlighter-rouge">q1</code>의 문자들 전부 추가.</li>
  <li><code class="highlighter-rouge">q1</code>에 <code class="highlighter-rouge">q2</code>문자들 전부 추가</li>
  <li>문자가 <code class="highlighter-rouge">NULL</code>일 때까지 1 ~ 3번 반복</li>
</ol>

<p>반복을 끝마치면 <code class="highlighter-rouge">q2</code>에 뒤집힌 문자열이 들어있게 된다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Reverse a string using two queues</span>
<span class="kt">void</span> <span class="nf">revstrstk</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">line</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">queue</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
	<span class="n">queue</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">q2</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">line</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
		
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q2</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
		<span class="p">{</span>
			<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">q2</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
			<span class="n">q2</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
		<span class="p">{</span>
			<span class="n">q2</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
			<span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="o">++</span><span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">line</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q2</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">q2</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
		<span class="n">q2</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
		<span class="o">++</span><span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>
<h2 id="사용-사례-">사용 사례 <a id="app"></a></h2>
<ul>
  <li>인터뷰 문제로 나온다</li>
  <li>Regex 역순으로 확인하면 효율적일때가 있다고 함 (Reference 확인)</li>
</ul>

<p><br /></p>
<h2 id="풀어-볼-문제-">풀어 볼 문제 <a id="try"></a></h2>
<ul>
  <li><a href="https://www.acmicpc.net/problem/10988">팰린드롬인지 확인하기</a></li>
</ul>

<p><br /></p>
<h2 id="reference">Reference<a id="ref"></a></h2>
<ul>
  <li><a href="https://softwareengineering.stackexchange.com/questions/24691/what-do-you-use-string-reversal-for">StackExchange : string reversal usage</a></li>
  <li><a href="https://www.perlmonks.org/index.pl?node=sexeger">sexeger</a></li>
</ul>
:ET