I"R=<h1 id="목차">목차</h1>
<ul>
  <li><a href="#concept">소개</a></li>
  <li><a href="#example">정렬 과정</a></li>
  <li><a href="#timecomp">시간 복잡도</a></li>
  <li><a href="#imp">구현</a>
    <ul>
      <li>C</li>
      <li>Python</li>
    </ul>
  </li>
  <li><a href="#try">풀어 볼 문제</a></li>
  <li><a href="#related">관련 글</a></li>
  <li><a href="#ref">참조</a></li>
</ul>
<hr />

<p><br /></p>

<h2 id="소개-">소개 <a id="concept"></a></h2>
<p>합병 정렬은 <strong>분할 정복 알고리즘</strong>(Divide and Conquer Algorithm)의 하나로 1945년에 <strong><a href="https://ko.wikipedia.org/wiki/%EC%A1%B4_%ED%8F%B0_%EB%85%B8%EC%9D%B4%EB%A7%8C">존 폰 노이만</a></strong>(John Von Neumann)이 고안한 알고리즘이다.</p>

<p>분할 정복 알고리즘은 하나의 큰 문제를 여러개의 작은 문제로 분할하여 해결한 뒤, 다시 하나로 합쳐 
결국 원래의 큰 문제를 해결해나가는 방법의 알고리즘이다.</p>

<p>또한 합병 정렬은 <strong>안전 정렬</strong>(Stable Sort)의 특성을 가지고 있어 분할하고 결합하는 과정에서 같은 요소들의 상대적 위치가 변하지 않는다.</p>

<p>예를들어 <code class="highlighter-rouge">{(A, 1), (B, 2), (C, 1)}</code>이 있고 숫자를 기준으로 정렬을 한다고 할 때, 
<code class="highlighter-rouge">A</code>는 언제나 <code class="highlighter-rouge">C</code>보다 먼저라는 것이 보장된다. 안전 정렬이 아닐 경우, 정렬의 결과가 <code class="highlighter-rouge">{(A,1), (C,1), (B,2)}</code> 또는 <code class="highlighter-rouge">{(C,1), (A,1), (B,2)}</code>이 되는데 어느 쪽 일지 알 수 없다.</p>

<p><br /></p>
<h2 id="정렬-과정-">정렬 과정 <a id="example"></a></h2>

<p>분할 정복은 다음의 세 단계를 거치며 진행된다:</p>
<ul>
  <li>분할 (Divide)</li>
  <li>정복 (Conquer)</li>
  <li>병합 (Combine)</li>
</ul>

<p><img src="/assets/images/algorithm/sorting/merge_sort.png" alt="merge sort" /></p>

<p><br /></p>
<h2 id="시간-복잡도-">시간 복잡도 <a id="timecomp"></a></h2>
<ul>
  <li>분할(Divide) 단계
    <ul>
      <li>각 리스트에서 중점(midpoint)를 찾는 연산이 반복된다. 이 연산 시간은 <strong>O(1)</strong> 이다.</li>
    </ul>
  </li>
  <li>정복(Conquer) 단계
    <ul>
      <li>분할 된 두 개의 리스트 속 <code class="highlighter-rouge">n/2</code>개의 요소들을 재귀적으로 정렬시킨다.</li>
    </ul>
  </li>
  <li>병합(Combine) 단계
    <ul>
      <li><code class="highlighter-rouge">n</code>개의 요소들을 병합한다. 이 연산은 <strong>O(n)</strong>의 시간이 걸린다.</li>
    </ul>
  </li>
</ul>

<p>위 과정들을 놓고 봤을 때 병합 단계의 시간 복잡도가 가장 크므로 총 시간 복잡도는  <strong>O(n)</strong>이 된다.</p>

<p>하지만 아래 병합 정렬의 트리 구조를 확인해보자.</p>

<p><img src="/assets/images/algorithm/sorting/merge_sort_time_complexity.png" alt="merge sort time complexity" /></p>

<p><code class="highlighter-rouge">n/2</code>단계는 두 번의 병합 과정을 거친다 → <strong>2 * n/2 = n</strong>. <br />
<code class="highlighter-rouge">n/4</code>단계는 네 번의 병합 과정을 거친다 → <strong>4 * n/4 = n</strong>. <br />
… <br />
<code class="highlighter-rouge">n</code>단계는 <code class="highlighter-rouge">c</code>개의 병합 과정을 거친다 → <strong>c * n = cn</strong>, <code class="highlighter-rouge">c</code>는 특정한 상수.</p>

<p>그렇다면 총 연산 횟수는 어떻게 될까?</p>

<p>트리의 높이는 <code class="highlighter-rouge">logn + 1</code>이고 이를 <code class="highlighter-rouge">cn</code>번 연산하여
<code class="highlighter-rouge">(logn + 1) * (cn)</code>이 된다.
 <code class="highlighter-rouge">n logn</code>이 <code class="highlighter-rouge">n</code>보다 크므로 병합 정렬의 총 
시간 복잡도는 <strong>O(n logn)</strong>이 된다.</p>

<p><br /></p>
<h2 id="합병-정렬-구현-">합병 정렬 구현 <a id="imp"></a></h2>
<h3 id="c언어">C언어</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sortedArr</span><span class="p">[</span><span class="n">SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="kt">int</span> <span class="n">L</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">R</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">K</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>

	<span class="c1">// combine two lists</span>
	<span class="k">while</span><span class="p">(</span><span class="n">L</span> <span class="o">&lt;=</span> <span class="n">mid</span> <span class="o">&amp;&amp;</span> <span class="n">R</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">L</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">R</span><span class="p">])</span>
		<span class="p">{</span>
			<span class="n">sortedArr</span><span class="p">[</span><span class="n">K</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">L</span><span class="o">++</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">sortedArr</span><span class="p">[</span><span class="n">K</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">R</span><span class="o">++</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Read all remaining data</span>
	<span class="k">while</span><span class="p">(</span><span class="n">L</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">sortedArr</span><span class="p">[</span><span class="n">K</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">L</span><span class="o">++</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="c1">// copy over the data</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">left</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">K</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sortedArr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mergeSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mid</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">mergeSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
		<span class="n">mergeSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
		<span class="n">merge</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>
<h3 id="python">Python</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
	<span class="n">L</span> <span class="o">=</span> <span class="n">left</span>
	<span class="n">R</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span>
	<span class="n">K</span> <span class="o">=</span> <span class="n">left</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

	<span class="k">while</span> <span class="n">L</span> <span class="o">&lt;=</span> <span class="n">mid</span> <span class="ow">and</span> <span class="n">R</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">L</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">R</span><span class="p">]:</span>
			<span class="n">temp</span><span class="p">[</span><span class="n">K</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">L</span><span class="p">]</span>
			<span class="n">L</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">temp</span><span class="p">[</span><span class="n">K</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">R</span><span class="p">]</span>
			<span class="n">R</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="n">K</span> <span class="o">+=</span> <span class="mi">1</span>

	<span class="k">while</span> <span class="n">L</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">:</span>
		<span class="n">temp</span><span class="p">[</span><span class="n">K</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">L</span><span class="p">]</span>
		<span class="n">L</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="n">K</span> <span class="o">+=</span> <span class="mi">1</span>

	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
		<span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">mergeSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
	<span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
		<span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
		
		<span class="n">mergeSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span>
		<span class="n">mergeSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
		<span class="n">merge</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
</code></pre></div></div>

<p><br /></p>
<h2 id="풀어-볼-문제-">풀어 볼 문제 <a id="try"></a></h2>
<ul>
  <li><a href="https://www.acmicpc.net/problem/10814">나이순 정렬</a></li>
  <li><a href="https://www.acmicpc.net/problem/2751">수 정렬하기 2</a></li>
</ul>

<p><br /></p>
<h2 id="관련-글--">관련 글  <a id="related"></a></h2>

<ul>
  <li>
    <p><a href="/algorithm/2019/08/06/ko-sorting-quick_sort.html">[알고리즘] 퀵 정렬</a></p>
  </li>
  <li>
    <p><a href="/algorithm/2019/08/04/ko-sorting-insertion_sort.html">[알고리즘] 삽입 정렬</a></p>
  </li>
  <li>
    <p><a href="/algorithm/2019/08/01/ko-sorting-selection_sort.html">[알고리즘] 선택 정렬</a></p>
  </li>
  <li>
    <p><a href="/algorithm/2019/07/28/ko-sorting-bubble_sort.html">[알고리즘] 거품 정렬</a></p>
  </li>
</ul>

<p><br /></p>
<h2 id="참조-">참조 <a id="ref"></a></h2>
<ul>
  <li><a href="https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html">[알고리즘] 합병 정렬(merge sort)이란</a></li>
  <li><a href="https://ko.wikipedia.org/wiki/%EC%A1%B4_%ED%8F%B0_%EB%85%B8%EC%9D%B4%EB%A7%8C">Wikipedia : John Von Neumann</a></li>
  <li><a href="https://softwareengineering.stackexchange.com/questions/297160/why-is-mergesort-olog-n">Stack Exchange : Merge Sort</a></li>
</ul>
:ET