I"-<p>연결 리스트로 스택을 구현 하고 컴파일 했더니,
서로 다른 자료형의 값을 대입하고 있다는 오류가 나왔다.</p>

<p>문제가 발생 한 부분은 아래와 같다:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">temp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">stack</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
</code></pre></div></div>
<p>구현을 제대로 했다면 필시 <code class="highlighter-rouge">next</code>와 <code class="highlighter-rouge">head</code> 자료형은 둘 다 <code class="highlighter-rouge">Node *</code> 일 터인데 왜 다른걸까? <br />
곰곰히 생각하던 중, “자료형을 출력 못하나?” 하는 생각이 들었다.</p>

<p>검색 결과 <code class="highlighter-rouge">_Generic</code>이라는 걸 발견했다. 아래의 코드를 살펴보자.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define typename(x) _Generic((x),                                                                     \
		_Bool: "_Bool",                              unsigned char: "unsigned char",          \
		char: "char",                                  signed char: "signed char",            \
		short int: "short int",                 unsigned short int: "unsigned short int",     \
		int: "int",                                   unsigned int: "unsigned int",           \
		long int: "long int",                    unsigned long int: "unsigned long int",      \
		long long int: "long long int",     unsigned long long int: "unsigned long long int", \
		float: "float",                                     double: "double",                 \
		long double: "long double",                         char *: "pointer to char",        \
		void *: "pointer to void",                           int *: "pointer to int",         \
		default: "other") 
</span></code></pre></div></div>

<p>위에서 지정한 매크로를 가지고 변수의 자료형을 출력할 수 있다. <br />
아래 예제는 첫 줄 부터 차례대로 int, char, double을 화면에 출력한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
	<span class="kt">double</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">"type of x: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="kr">typename</span><span class="p">(</span><span class="n">x</span><span class="p">));</span> <span class="c1">// output "int"</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"type of y: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="kr">typename</span><span class="p">(</span><span class="n">y</span><span class="p">));</span> <span class="c1">// output "char"</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"type of z: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="kr">typename</span><span class="p">(</span><span class="n">z</span><span class="p">));</span> <span class="c1">// output "double"</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>그럼 본론으로 돌아와서, <code class="highlighter-rouge">struct Node * : "pointer to Node"</code>를 매크로에 추가하고<br />
<code class="highlighter-rouge">temp-&gt;next</code>와 <code class="highlighter-rouge">stk-&gt;head</code>의 자료형이 뭔지 출력해보자.</p>

<p>출력 했더니<code class="highlighter-rouge">other</code>와 <code class="highlighter-rouge">pointer to Node</code>가 나왔다. <code class="highlighter-rouge">temp-&gt;next</code>의 자료형이 <code class="highlighter-rouge">Node *</code>가
아니라는 의미다.</p>

<p>노드의 구조체를 다시 한 번 찬찬히 살펴봤다.</p>

<p>오류가 있었다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="c1">// code</span>
<span class="p">}</span> <span class="n">Node</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="c1">// code</span>
<span class="p">}</span> <span class="n">Stack</span><span class="p">;</span>
</code></pre></div></div>

<p>위 코드는 아래와 같이 되어야 한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Node</span><span class="p">{</span>
	<span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="c1">// code</span>
<span class="p">}</span> <span class="n">Node</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Stack</span> <span class="p">{</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="c1">// code</span>
<span class="p">}</span> <span class="n">Stack</span><span class="p">;</span>
</code></pre></div></div>

<p><br /></p>
<h2 id="reference">Reference</h2>
<ul>
  <li><a href="https://stackoverflow.com/questions/6280055/how-do-i-check-if-a-variable-is-of-a-certain-type-compare-two-types-in-c">StackOverflow : Checking certain type</a></li>
  <li><a href="https://stackoverflow.com/questions/17720223/c-typedef-struct-name-vs-typedef-struct-name/23660072">StackOverflow : typedef struct</a></li>
</ul>
:ET