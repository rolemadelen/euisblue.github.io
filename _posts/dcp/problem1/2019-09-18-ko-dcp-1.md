---
layout: post
title: "Daily Coding Problem #1"
ref: dcp-1
date: 2019-09-18 07:00:00
categories: DCP
tags: dcp
lang: ko
---

## DCP란?
[Daily Coding Problem](https://www.dailycodingproblem.com)의 가서 subscribe를 하면 매일 한 개의 코딩 문제를 이메일로 보내준다. 

실제 회사에서 개발자들이 받았던 면접 문제들을 기반으로 만든 문제라고 하는데 단순히 면접을 떠나서 
이런 문제들은 사고력과 논리력에 도움이 될거라고 생각해서 필자도 풀어보려고 한다.

문제들은 필자의 최애 언어인 C(귀찮을땐 C++)와 현재 공부중인 Ruby로 작성할 예정이다.

다만 같은 코드를 다른 언어로 글에 올리는 것은 의미가 없다 생각해서 Ruby 코드만 올리려고 한다.

C 또는 C++로 작성한 코드를 보고싶다면 필자의 [GitHub](https://github.com/muicode/DCP)를 확인해주길 바란다.

참고로 DCP에서 프리미엄 멤버의 경우 정답 코드를 다음 날 보내주는데 필자는 그렇지 않은 관계로 정답 코드를 확인 할 수가 없다.

그러니 오류가 있다면 피드백을, 더 좋은 방법이 있다면 코드의 공유를 해주면 감사할 따름이다.

그럼 첫 번째 문제를 풀어보자.

<br>

## DCP #1
이 문제는 실제 구글 면접에서 나온 질문이다.

정수의 배열과 정수 k가 주어졌을 때, 배열 속 두 정수의 합이 k가 되는지 확인하는 프로그램을 작성하라. 

예를들어, 배열의 값으로 `[10, 15, 3, 7]` 그리고 `k`로 `17`이 주어질 경우, `10 + 7`은 `k` 이므로 참을 반환한다. 

보너스: 원 패스(one pass)로 문제를 풀 수 있는가?

[원문 읽기](en-dcp-1.html#dcp1)

 <br>

## 코드 & 설명

### Bruteforce
일차원적으로 접근한다면 배열의 모든 원소를 하나하나 확인하는 브루트포스 방법이 있다.

```ruby
def bruteforce(arr, k)
    n = arr.size

    for i in (0 ... n - 1)
        for j in (i + 1 ... n)
            if arr[i] + arr[j] == k
                puts "found: #{arr[i]} + #{arr[j]} = #{k}"
                return
            end
        end
    end
    puts "none exists"
end
```

배열의 첫 번째 원소부터 시작해 나머지 원소들과 하나 씩 더해가면서 `k`와 일치하는지 확인한다.
여기서는 `puts`를 사용했지만 일치하면 참을 아니면 거짓을 반환한다.

시간복잡도는 **O(n^2)** 

연산 하면서 사용되는 추가적인 메모리는 없기 때문에 공간 복잡도는 **O(1)**이다.

<br>

### Two-Pass

브루트포스는 아무래도 데이터의 크기가 커지면 커질수록 느려질 수 밖에 없다.

보너스 문제에서도 힌트를 주듯이 O(n)으로 풀 수 있다. 하지만 일단 one-pass로 가기 전, two-pass로 풀어보자.

```ruby
def two_pass(arr, k)
    m = []

    arr.each do |n|
        m.insert(n)
    end

    arr.each do |n|
        if m.include? (k - n)
            puts "found: #{k - n} + #{n} = #{k}"
            return
        end
    end
    puts "none exists"
end
```

우선 첫 번째 패스에서 새로운 배열 `m`에 모든 데이터를 집어 넣는다.

그리고 두 번째 패스에서 배열 `m`에 `k - n`이 존재하는지 확인한다.
존재하면 두 수의 합이 `k` 가 되므로 참을 반환한다. 전부 순회했을 때 값을 찾을 수 없었다면, 존재하지 않으므로 거짓을 반환한다.

위 공식(?)이 성립하는 이유는 아주 간단한 수학에서 비롯된다. 

배열 속 두 개의 정수 `a`, `b`의 합이 `k`가 되어야 한다. 즉 `a + b = k`다.

여기서 `a`를 반대쪽으로 이동시키면 `k - a = b`가 된다. 

현재 배열에서 내가 보고 있는 값이 `a`고 `k - a`가 배열 어딘가에 존재한다는 것은 `a + b`가 `k`라는 것과
일치하기 때문에 바로 참을 반환하는 것이 가능하다.

시간복잡도는 O(2n) => **O(n)**이다.

`k - n`을 찾기 위해 배열을 추가적으로 사용하므로 공간복잡도는 **O(n)**이 된다.

<br>

### One-Pass

위에서 작성한 two-pass를 one-pass로 구현해보자.

```ruby
def one_pass(arr, k)
    m = []

    arr.each do |n|
        if m.include? (k - n)
            puts "found: #{k - n} + #{n} = #{k}"
            return
        else
            m.insert(n)
        end
    end
    puts "none exists"
end
```

모든 값을 배열에 먼저 저장하지 않고, 새로운 원소(`a`)에 접근하는 순간순간 `k - a`가 존재하는지 확인하고 존재하면 참을, 그렇지 않으면 `a`를 배열에 저장한다.

이렇게 할 경우, 주어진 배열의 크기보다 적은 크기의 메모리를 사용한다는 것이 보장되며 빠를 경우는 O(1)의 공간만을 사용한다.

물론 최악의 경우 공간복잡도는 **O(n)**이고 시간복잡도 역시 **O(n)**이다.