---
layout: post
title: "Daily Coding Problem #1"
ref: dcp-1
date: 2019-09-18 07:00:00
categories: DCP
tags: dcp
lang: en
---

## What is DCP?
When you subscribe to [Daily Coding Problem](https://www.dailycodingproblem.com), you will receive a coding problem every day to
solve it. 

These problems were actually asked by top companies during a coding interview, so it should be good practice if you're
preparing for a job interview. Even if you're not, I believe this type of problem will help you to think more logically so
I'm going to give it a shot.

I will be using my favority programming language C (C++ when I'm lazy) and Ruby, the one I'm currently studying.

However, there's no point of posting two same codes just in different languages so I'll only post Ruby code here.

If you want to look at my C or C++ code solutions, please visit my [GitHub](https://github.com/muicode/DCP).

By the way, if you're a premium member at DCP, they will send you the solution the following day; however, I am not. 
So if you find any errors in my code or you have a better solution, please share it with me.

Well then, here it goes the first problem.

<br>

## DCP #1  <a id="dcp1"></a>
This problem was recently asked by Google.

Given a list of numbers and a number k, return whether any two numbers from the list add up to k.

For example, given [10, 15, 3, 7] and k of 17, return true since 10 + 7 is 17.

Bonus: Can you do this in one pass?

<br>

## My Solution

### Bruteforce

We can use brute force type algorithm here to find whether two values sum up to `k`.

```ruby
def bruteforce(arr, k)
    n = arr.size

    for i in (0 ... n - 1)
        for j in (i + 1 ... n)
            if arr[i] + arr[j] == k
                puts "found: #{arr[i]} + #{arr[j]} = #{k}"
                return
            end
        end
    end
    puts "none exists"
end
```

Starting from the first element, we can add rest of them one by one and see if it equals to `k`.
If it dose we return True and False if not.

The time complexity for this algorithm would be **O(n^2)**.

Since we didn't use any extra array, the space complexity is **O(1)**.

<br>

### Two-Pass

Brute force algorithm tends to get slower as data gets bigger (obviously its O(n^2) right?).

We know we can solve it faster from the _bonus_ part we saw up there about using the _one-pass_.
Before we try that, lets solve it using a _two-pass_ algorithm.

```ruby
def two_pass(arr, k)
    m = []

    arr.each do |n|
        m.insert(n)
    end

    arr.each do |n|
        if m.include? (k - n)
            puts "found: #{k - n} + #{n} = #{k}"
            return
        end
    end
    puts "none exists"
end
```

First we create an array `m` to store all data.

And then, we try to find whether `k - n` exists in `m`. If it does we return True. 
If we don't find any after iterating all elements, we return False.

This is basic math.

Let say we have two numbers `a` and `b` and these must sum up to `k`. 

So `a + b = k`

Lets move the `a` to the other side, then we get `k - a = b`

Our current index (arr[i]) is pointing at `a` and if `k - a` happens to exist in an array,
that means `a + b = k` so we are able to say that these values exist and return True.

The time complexity is O(2n) => **O(n)**.

Since we used additional array to store all data, the space complexity becomes **O(n)**.

<br>

### One-Pass

Lets solve it with one-pass.

```ruby
def one_pass(arr, k)
    m = []

    arr.each do |n|
        if m.include? (k - n)
            puts "found: #{k - n} + #{n} = #{k}"
            return
        else
            m.insert(n)
        end
    end
    puts "none exists"
end
```

Here, we create an array `m` but we don't store all elements first.

As we iterate each element, let say`a`, from the given array, we immideately search for `k - a`. If it exists, then we return True. 
If not, we insert `a` to `m`.

This way, we are guranteed to use less storage which can be small as O(1).

Although in worst case, the space complexity will still be **O(n)** and the time complexity will also be **O(n)**. 